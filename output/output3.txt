Token            Lexeme
------------------------------
Separator    | $
Separator    | $
Keyword      | integer
Identifier   | i
Separator    | ,
Identifier   | max
Separator    | ,
Identifier   | sum
Separator    | ;
Keyword      | boolean
Identifier   | yes
Separator    | ,
Identifier   | no
Separator    | ;
Separator    | $
Separator    | {
Identifier   | sum
Operator     | =
Integer      | 0
Separator    | ;
Identifier   | i
Operator     | =
Integer      | 1
Separator    | ;
Keyword      | scan
Separator    | (
Identifier   | max
Separator    | )
Separator    | ;
Separator    | {
Keyword      | while
Separator    | (
Identifier   | i
Operator     | <
Identifier   | max
Separator    | )
Separator    | {
Identifier   | sum
Operator     | =
Identifier   | sum
Operator     | +
Identifier   | i
Separator    | ;
Identifier   | i
Operator     | =
Identifier   | i
Operator     | +
Integer      | 1
Separator    | ;
Separator    | }
Keyword      | endwhile
Separator    | }
Separator    | }
Separator    | {
Identifier   | no
Operator     | =
Keyword      | false
Separator    | ;
Keyword      | scan
Separator    | (
Identifier   | yes
Separator    | )
Separator    | ;
Keyword      | if
Separator    | (
Identifier   | yes
Operator     | ==
Identifier   | no
Separator    | )
Separator    | {
Identifier   | max
Operator     | =
Identifier   | yes
Operator     | +
Identifier   | no
Separator    | ;
Identifier   | no
Operator     | =
Keyword      | true
Separator    | ;
Separator    | }
Keyword      | endif
Separator    | }
Keyword      | print
Separator    | (
Identifier   | no
Separator    | )
Separator    | ;
Keyword      | print
Separator    | (
Identifier   | sum
Operator     | +
Identifier   | max
Separator    | )
Separator    | ;
Separator    | $

Syntax Analysis:
------------------------------
<Rat24S> ::= $ <Opt Function Definitions> $ <Opt Declaration List> $ <Statement List> $
Token: Separator Lexeme: $
<Opt Function Definitions> ::= <Function Definitions> | <Empty>
<Empty> ::= epsilon
Token: Separator Lexeme: $
<Opt Declaration List> ::= <Declaration List> | <Empty>
<Declaration List> ::= <Declaration> ; <Declaration List'>
<Declaration> ::= <Qualifier> <IDs>
<Qualifier> ::= integer | boolean | real
Token: Keyword Lexeme: integer
<IDs> ::= <Identifier> <IDs'>
Token: Identifier Lexeme: i
<IDs'> ::= , <IDs> | epsilon
Token: Separator Lexeme: ,
<IDs> ::= <Identifier> <IDs'>
Token: Identifier Lexeme: max
<IDs'> ::= , <IDs> | epsilon
Token: Separator Lexeme: ,
<IDs> ::= <Identifier> <IDs'>
Token: Identifier Lexeme: sum
<IDs'> ::= , <IDs> | epsilon
Token: Separator Lexeme: ;
<Declaration List'> ::= <Declaration List> | epsilon
<Declaration List> ::= <Declaration> ; <Declaration List'>
<Declaration> ::= <Qualifier> <IDs>
<Qualifier> ::= integer | boolean | real
Token: Keyword Lexeme: boolean
<IDs> ::= <Identifier> <IDs'>
Token: Identifier Lexeme: yes
<IDs'> ::= , <IDs> | epsilon
Token: Separator Lexeme: ,
<IDs> ::= <Identifier> <IDs'>
Token: Identifier Lexeme: no
<IDs'> ::= , <IDs> | epsilon
Token: Separator Lexeme: ;
<Declaration List'> ::= <Declaration List> | epsilon
Token: Separator Lexeme: $
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Compound> ::= { <Statement List> }
Token: Separator Lexeme: {
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: sum
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Integer Lexeme: 0
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: i
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Integer Lexeme: 1
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Scan> ::= scan ( <IDs> );
Token: Keyword Lexeme: scan
Token: Separator Lexeme: (
<IDs> ::= <Identifier> <IDs'>
Token: Identifier Lexeme: max
<IDs'> ::= , <IDs> | epsilon
Token: Separator Lexeme: )
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Compound> ::= { <Statement List> }
Token: Separator Lexeme: {
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<While> ::= while ( <Condition> ) <Statement> endwhile
Token: Keyword Lexeme: while
Token: Separator Lexeme: (
<Condition> ::= <Expression> <Relop> <Expression>
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: i
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
<Relop> ::= == | != | > | < | <= | =>
Token: Operator Lexeme: <
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: max
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: )
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Compound> ::= { <Statement List> }
Token: Separator Lexeme: {
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: sum
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: sum
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Operator Lexeme: +
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: i
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: i
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: i
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Operator Lexeme: +
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Integer Lexeme: 1
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
Token: Separator Lexeme: }
Token: Keyword Lexeme: endwhile
<Statement List'> ::= <Statement List> | epsilon
Token: Separator Lexeme: }
<Statement List'> ::= <Statement List> | epsilon
Token: Separator Lexeme: }
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Compound> ::= { <Statement List> }
Token: Separator Lexeme: {
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: no
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Keyword Lexeme: false
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Scan> ::= scan ( <IDs> );
Token: Keyword Lexeme: scan
Token: Separator Lexeme: (
<IDs> ::= <Identifier> <IDs'>
Token: Identifier Lexeme: yes
<IDs'> ::= , <IDs> | epsilon
Token: Separator Lexeme: )
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<If> ::= if ( <Condition> ) <Statement> <If'>
Token: Keyword Lexeme: if
Token: Separator Lexeme: (
<Condition> ::= <Expression> <Relop> <Expression>
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: yes
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
<Relop> ::= == | != | > | < | <= | =>
Token: Operator Lexeme: ==
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: no
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: )
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Compound> ::= { <Statement List> }
Token: Separator Lexeme: {
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: max
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: yes
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Operator Lexeme: +
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: no
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: no
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Keyword Lexeme: true
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
Token: Separator Lexeme: }
<If'> ::= endif | else <Statement> endif
Token: Keyword Lexeme: endif
<Statement List'> ::= <Statement List> | epsilon
Token: Separator Lexeme: }
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Print> ::= print ( <Expression> );
Token: Keyword Lexeme: print
Token: Separator Lexeme: (
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: no
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: )
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Print> ::= print ( <Expression> );
Token: Keyword Lexeme: print
Token: Separator Lexeme: (
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: sum
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Operator Lexeme: +
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: max
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
Token: Separator Lexeme: )
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
Token: Separator Lexeme: $
end of list
------------------------------

Symbol Table:
Identifier	Memory Address	Type
i		5000		integer
max		5001		integer
sum		5002		integer
yes		5003		boolean
no		5004		boolean


Instr Table:
Address	Operation	Operand
1		PUSHI		0
2		POPM		5002
3		PUSHI		1
4		POPM		5000
5		SIN
6		POPM		5001
7		LABEL
8		PUSHM		5000
9		PUSHM		5001
10		LES
11		JUMP0		21
12		PUSHM		5002
13		PUSHM		5000
14		A
15		POPM		5002
16		PUSHM		5000
17		PUSHI		1
18		A
19		POPM		5000
20		JUMP		7
21		PUSHI		0
22		POPM		5004
23		SIN
24		POPM		5003
25		PUSHM		5003
26		PUSHM		5004
27		EQU
28		JUMP0		35
29		PUSHM		5003
30		PUSHM		5004
31		A
32		POPM		5001
33		PUSHI		1
34		POPM		5004
35		LABEL
36		PUSHM		5004
37		SOUT
38		PUSHM		5002
39		PUSHM		5001
40		A
41		SOUT
