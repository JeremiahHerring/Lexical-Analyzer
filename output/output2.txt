Token            Lexeme
------------------------------
Separator    | $
Separator    | $
Keyword      | integer
Identifier   | a
Separator    | ,
Identifier   | b
Separator    | ,
Identifier   | c
Separator    | ,
Identifier   | d
Separator    | ;
Separator    | $
Identifier   | a
Operator     | =
Integer      | 1
Separator    | ;
Identifier   | b
Operator     | =
Integer      | 2
Separator    | ;
Identifier   | c
Operator     | =
Integer      | 3
Separator    | ;
Identifier   | d
Operator     | =
Integer      | 4
Separator    | ;
Keyword      | if
Separator    | (
Identifier   | a
Operator     | <
Identifier   | b
Separator    | )
Separator    | {
Identifier   | a
Operator     | =
Identifier   | c
Separator    | ;
Separator    | }
Keyword      | else
Separator    | {
Identifier   | a
Operator     | =
Identifier   | d
Separator    | ;
Separator    | }
Keyword      | endif
Separator    | $

Syntax Analysis:
------------------------------
<Rat24S> ::= $ <Opt Function Definitions> $ <Opt Declaration List> $ <Statement List> $
Token: Separator Lexeme: $
<Opt Function Definitions> ::= <Function Definitions> | <Empty>
<Empty> ::= epsilon
Token: Separator Lexeme: $
<Opt Declaration List> ::= <Declaration List> | <Empty>
<Declaration List> ::= <Declaration> ; <Declaration List'>
<Declaration> ::= <Qualifier> <IDs>
<Qualifier> ::= integer | boolean | real
Token: Keyword Lexeme: integer
<IDs> ::= <Identifier> <IDs'>
Token: Identifier Lexeme: a
<IDs'> ::= , <IDs> | epsilon
Token: Separator Lexeme: ,
<IDs> ::= <Identifier> <IDs'>
Token: Identifier Lexeme: b
<IDs'> ::= , <IDs> | epsilon
Token: Separator Lexeme: ,
<IDs> ::= <Identifier> <IDs'>
Token: Identifier Lexeme: c
<IDs'> ::= , <IDs> | epsilon
Token: Separator Lexeme: ,
<IDs> ::= <Identifier> <IDs'>
Token: Identifier Lexeme: d
<IDs'> ::= , <IDs> | epsilon
Token: Separator Lexeme: ;
<Declaration List'> ::= <Declaration List> | epsilon
Token: Separator Lexeme: $
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: a
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Integer Lexeme: 1
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: b
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Integer Lexeme: 2
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: c
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Integer Lexeme: 3
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: d
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Integer Lexeme: 4
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<If> ::= if ( <Condition> ) <Statement> <If'>
Token: Keyword Lexeme: if
Token: Separator Lexeme: (
<Condition> ::= <Expression> <Relop> <Expression>
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: a
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
<Relop> ::= == | != | > | < | <= | =>
Token: Operator Lexeme: <
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: b
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: )
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Compound> ::= { <Statement List> }
Token: Separator Lexeme: {
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: a
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: c
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
Token: Separator Lexeme: }
<If'> ::= endif | else <Statement> endif
Token: Keyword Lexeme: else
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Compound> ::= { <Statement List> }
Token: Separator Lexeme: {
<Statement List> ::= <Statement> <Statement List'>
<Statement> ::= <Compound> | <Assign> | <If> | <Return> | <Print> | <Scan> | <While>
<Assign> ::= <Identifier> = <Expression> ;
Token: Identifier Lexeme: a
Token: Operator Lexeme: =
<Expression> ::= <Term> <Expression'>
<Term> ::= <Factor> <Term'>
<Factor> ::= - <Primary> | <Primary>
<Primary> ::= <Identifier> <Primary’> |  <Integer> <Primary’> | <Real> <Primary’> | true <Primary’> | false <Primary’> | ( <Expression> ) <Primary’>
Token: Identifier Lexeme: d
<Primary’> ::= ( <IDs> ) <Primary’> | epsilon
<Term'> ::= * <Factor> <Term'> | / <Factor> <Term'> | epsilon
<Expression'> ::= + <Term> <Expression'> | - <Term> <Expression'> | epsilon
Token: Separator Lexeme: ;
<Statement List'> ::= <Statement List> | epsilon
Token: Separator Lexeme: }
Token: Keyword Lexeme: endif
<Statement List'> ::= <Statement List> | epsilon
Token: Separator Lexeme: $
end of list
------------------------------

Symbol Table:
Identifier	Memory Address	Type
a		5000		integer
b		5001		integer
c		5002		integer
d		5003		integer


Instr Table:
Address	Operation	Operand
1		PUSHI		1
2		POPM		5000
3		PUSHI		2
4		POPM		5001
5		PUSHI		3
6		POPM		5002
7		PUSHI		4
8		POPM		5003
9		PUSHM		5000
10		PUSHM		5001
11		LES
12		JUMP0		15
13		PUSHM		5002
14		POPM		5000
15		LABEL
16		PUSHM		5003
17		POPM		5000
